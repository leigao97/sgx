#include <torch/extension.h>
#include "sgx_urts.h"
#include "ops_sim_u.h"   // generated by sgx_edger8r from ops_sim.edl

// initialize the enclave once
static sgx_enclave_id_t enclave_id = 0;
static void init_enclave() {
  if (enclave_id) return;
  sgx_launch_token_t token = {0};
  int updated = 0;
  sgx_create_enclave("Enclave/Enclave.signed.so",
                     SGX_DEBUG_FLAG, &token, &updated, &enclave_id, nullptr);
}

torch::Tensor add_one(const torch::Tensor& x) {
  init_enclave();
  auto flat = x.contiguous().view(-1);
  size_t N = flat.numel();
  auto out = torch::empty_like(flat);

  // marshal pointers through the enclave
  ecall_add_one(enclave_id,
                flat.data_ptr<float>(),
                N,
                out.data_ptr<float>());

  return out.view(x.sizes());
}

torch::Tensor add_noise(const torch::Tensor& x) {
  init_enclave();
  auto flat = x.contiguous().view(-1);
  size_t N = flat.numel();
  auto out = torch::empty_like(flat);

  ecall_add_noise(enclave_id,
                  flat.data_ptr<float>(),
                  N,
                  out.data_ptr<float>());

  return out.view(x.sizes());
}

TORCH_LIBRARY(ops_sgx, m) {
    m.def("add_one(Tensor x) -> Tensor");
    m.def("add_noise(Tensor x) -> Tensor");
}

TORCH_LIBRARY_IMPL(ops_sgx, CPU, m) {
    m.impl("add_one",   torch::dispatch(c10::DispatchKey::CPU, TORCH_FN(add_one)));
    m.impl("add_noise", torch::dispatch(c10::DispatchKey::CPU, TORCH_FN(add_noise)));
}